<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    var b = 1;
function someFunction(number) {
function otherFunction(input) {
return b;
}
b = 5;
return otherFunction;
}
var firstResult = someFunction(9);
var result = firstResult(2);

//  I did see the code eventually and I was very wrong. I took a long time understanding closures more 
// firstResult, will return otherFunction since it's equal to someFunction(); the parameter 9 doesn't matter at all 
// in this case, we have no reference to number anywhere else or to the parameter. 
// result will return otherfunction(); which is the value of b. It will be 5. 
// Why 5? Because otherFunction will look for the value of b, firstly inside of itself, it won't find it.
// so it goes to its parent scope, which is someFunction. There the value of b is 5, so it takes it and 
// closures on it, so preserves it. Now it will keep value of b=5; even if the function is ran outside in the global variable and the global decleration is ignored.


var a = 1;
function b2() {
a = 10;
return;
function a() { }
}
b2();
console.log(a);

// I also did run this code eventually. Everything about closures leads me to think console log (a) will return 10;
// It shoudln't return one. I am trying to think why it did return one, my best guess since we ran a function declared
// as a it reassigned the value after the return to the global scope again so it became a=1 

let i;
for (i = 0; i < 3; i++) {
const log = () => {
console.log(i);
}
setTimeout(log, 100);
}
// setTimeout delays the running of the code by 100 ms, in that time before JS executes the code,
// it needs to put the function and the variable value in it in a closure. The final value of i should be 3 
// because this is when the loop ends.
  </script>
</body>
</html>